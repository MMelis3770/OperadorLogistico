@using System.Text.Json
@using Newtonsoft.Json.Linq
@using System.Reflection
@using System.IO
@using System.Text
@using BlazorTemplate.Models
@using BlazorTemplate.Interfaces
@using Microsoft.FluentUI.AspNetCore.Components
@using BlazorTemplate.Services
@using BlazorTemplate.Components.Dialog
@inject IDialogService _dialogService
@inject IOrderService _orderService
@inject ISelectedOrdersService _selectedOrdersService
@inject IBatchService _batchService
@page "/LayoutBatch"
@implements IDisposable

<PageTitle>Batch Management</PageTitle>
<h1>Batch Management</h1>

<FluentStack Orientation="Orientation.Horizontal" HorizontalGap="8">
    <NavLink href="/TestTemplate" style="text-decoration: none;">
        <button style="background: none; border: none; padding: 4px; margin: 0; cursor: pointer; display: flex; justify-content: center; align-items: center;">
            <FluentIcon Value="@(new Icons.Regular.Size24.ArrowUndo())" Color="Color.Accent" />
        </button>
    </NavLink>
    <FluentSpacer />
    <FluentButton Appearance="Appearance.Accent" Style="margin-right: 40px" BackgroundColor="#28a745" OnClick="@ProcessSelectedOrders">Process Orders</FluentButton>
    @if (isLoading)
    {
        <FluentProgressRing />
        <span>Loading orders...</span>
    }
</FluentStack>

<!-- Contenedor principal -->
<div class="grid-and-pagination-container">
    <!-- Contenedor del grid -->
    <div class="fixed-height-grid-container">
        <FluentDataGrid Items="@orders" TGridItem="Order" Pagination="@pagination" Class="fixed-row-grid">

            <PropertyColumn Property="@(o => o.ID)" Sortable="true" />
            <PropertyColumn Property="@(o => o.Client)" Sortable="true" />
            <PropertyColumn Property="@(o => o.Date)" Format="yyyy-MM-dd" Sortable="true" />
            <PropertyColumn Property="@(o => o.Expiration)" Format="yyyy-MM-dd" Sortable="true" />
            <PropertyColumn Property="@(o => o.LineCount)" Title="Lines" Sortable="true" />
            <TemplateColumn Title="">
                <ChildContent>
                    <button @onclick="@(() => HandleRowClick(context))"
                            style="background: none; border: none; padding: 0; margin: 0; cursor: pointer; display: flex; justify-content: center; align-items: center;">
                        <FluentIcon Value="@(new Icons.Regular.Size20.Eye())" Color="Color.Accent" />
                    </button>
                </ChildContent>
            </TemplateColumn>
            <TemplateColumn Title="">
                <ChildContent>
                    <button @onclick="@(() => HandleDeleteClick(context))"
                            style="background: none; border: none; padding: 0; margin: 0; cursor: pointer; display: flex; justify-content: center; align-items: center;">
                        <FluentIcon Value="@(new Icons.Regular.Size20.Delete())" Color="Color.Accent" />
                    </button>
                </ChildContent>
            </TemplateColumn>
        </FluentDataGrid>
    </div>

    <!-- Contenedor para el contador y paginador -->
    <div class="paginator-container">
        <div class="left-section"></div>
        <div class="right-section">
            <FluentPaginator State="@pagination" />
        </div>
    </div>
</div>

@if (selectedOrder != null)
{
    <h2>Detalle de Comanda: @selectedOrder.ID - @selectedOrder.Client</h2>

    @if (selectedOrderItems != null && selectedOrderItems.Any())
    {
        <div class="detail-container">
            <FluentDataGrid Items="@selectedOrderItems" TGridItem="OrderLineItem" Class="detail-grid">
                <PropertyColumn Property="@(li => li.LineNumber + 1)" Title="Line" Sortable="true" />
                <PropertyColumn Property="@(li => li.ItemCode)" Title="Item" Sortable="true" />
                <PropertyColumn Property="@(li => li.Quantity)" Title="Quantity" Sortable="true" />
                <TemplateColumn Title="Batch">
                    <ChildContent>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            @{
                                var hasStock = HasSufficientStockForLine(context);
                            }

                            @if (!hasStock)
                            {
                                <FluentIcon Value="@(new Icons.Regular.Size16.Warning())" Color="Color.Error" />
                                <span style="color: red; font-size: 12px;">Insufficient stock</span>
                            }
                            else
                            {
                                <button @onclick="@(() => OpenBatchAssignmentDialog(context))"
                                        style="background: none; border: none; padding: 0; margin: 0; cursor: pointer; display: flex; justify-content: center; align-items: center;"
                                        title="Edit Batch Assignment">
                                    <FluentIcon Value="@(new Icons.Regular.Size20.Edit())" Color="Color.Accent" />
                                </button>
                            }
                        </div>
                    </ChildContent>
                </TemplateColumn>
                <TemplateColumn Title="Information">
                    <ChildContent>
                        @if (!string.IsNullOrEmpty(context.Batch))
                        {
                            <button @onclick="@(() => OpenBatchInfoDialog(context))"
                                    style="background: none; border: none; padding: 0; margin: 0; cursor: pointer; display: flex; justify-content: center; align-items: center;"
                                    title="View Assigned Batch Information">
                                <FluentIcon Value="@(new Icons.Regular.Size20.SlideSearch())" Color="Color.Accent" />
                            </button>
                        }
                    </ChildContent>
                </TemplateColumn>
            </FluentDataGrid>
        </div>
    }
    else
    {
        <div class="alert alert-info" style="margin-top: 20px">
            There are no lines available for this order.
        </div>
    }
}

<!-- Componente de diálogo para asignar batch -->
<BatchAssignmentDialog IsOpen="@isBatchDialogOpen"
                       IsOpenChanged="@HandleDialogClosed"
                       OrderId="@currentOrderId"
                       LineNumber="@currentLineNumber"
                       ItemCode="@currentItemCode"
                       Quantity="@currentQuantity"
                       OnBatchAssigned="@HandleBatchAssigned" />

<!-- Componente de diálogo para información de batch -->
<BatchInfoDialog IsOpen="@isInfoDialogOpen"
                 IsOpenChanged="@HandleInfoDialogClosed"
                 OrderId="@currentOrderId"
                 LineNumber="@currentLineNumber"
                 ItemCode="@currentItemCode"
                 Quantity="@currentQuantity" />

@code {
    record Order(int ID, string Client, DateOnly Date, DateOnly Expiration, int LineCount);
    record OrderLineItem(int LineNumber, string ItemCode, int Quantity, string Batch);

    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };
    private IQueryable<Order> orders;
    private List<OrderData> processedOrders = new List<OrderData>();
    private Order selectedOrder;
    private IQueryable<OrderLineItem> selectedOrderItems;
    private System.Threading.Timer refreshTimer;
    private bool isLoading = false;

    // Variables para el diálogo de asignación de batch
    private bool isBatchDialogOpen = false;
    // Variables para el diálogo de información de batch
    private bool isInfoDialogOpen = false;

    private int currentOrderId;
    private int currentLineNumber;
    private string currentItemCode;
    private int currentQuantity;
    // Diccionari per guardar l'estat del stock de cada línia
    private Dictionary<(int OrderId, int LineNumber), bool> _stockAvailabilityCache = new Dictionary<(int OrderId, int LineNumber), bool>();


    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        // Cargar órdenes seleccionadas al inicializar
        await LoadSelectedOrders();
    }

    // Cargar las órdenes seleccionadas desde el servicio compartido
    private async Task LoadSelectedOrders()
    {
        try
        {
            isLoading = true;
            StateHasChanged();

            // Obtener las órdenes del servicio compartido
            var selectedOrdersData = _selectedOrdersService.SelectedOrders;

            if (selectedOrdersData != null && selectedOrdersData.Any())
            {
                processedOrders = selectedOrdersData;

                // Convertir a formato para la grid
                var orderList = processedOrders.Select(o => new Order(
                    o.DocEntry,
                    o.CardCode,
                    DateOnly.FromDateTime(o.OrderDate),
                    DateOnly.FromDateTime(o.DocDueDate),
                    o.LineItems.Count
                )).ToList();

                orders = orderList.AsQueryable();

                // Mostrar mensaje informativo
                await _dialogService.ShowInfoAsync($"Se han cargado {processedOrders.Count} comandas seleccionadas.", "Información");
            }
            else
            {
                // Si no hay órdenes seleccionadas, mostrar grid vacío
                orders = new List<Order>().AsQueryable();
                await _dialogService.ShowInfoAsync("No hay comandas seleccionadas para procesar.", "Información");
            }
        }
        catch (Exception ex)
        {
            await _dialogService.ShowErrorAsync($"Error al cargar comandas seleccionadas: {ex.Message}", "Error");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async void HandleRowClick(Order order)
    {
        if (order == null || order.ID <= 0) return;  // Ignorar clics en filas vacías (ID ≤ 0)

        selectedOrder = order;
        StateHasChanged(); // Forzar actualización para mostrar el encabezado de la sección de detalles

        // Busca en las órdenes procesadas
        var orderData = processedOrders.FirstOrDefault(o => o.DocEntry == selectedOrder.ID);

        if (orderData != null && orderData.LineItems.Any())
        {
            // NOVA FUNCIONALITAT: Validar stock per a cada línia
            _stockAvailabilityCache.Clear(); // Netejar cache anterior

            bool anyStockIssue = false;
            StringBuilder errorMessageBuilder = new StringBuilder();
            errorMessageBuilder.AppendLine("Se han detectado problemas de stock en los siguientes artículos:");
            errorMessageBuilder.AppendLine();

            foreach (var line in orderData.LineItems)
            {
                var (hasSufficientStock, availableQuantity) = await _batchService.ValidateStockAvailabilityAsync(line.ItemCode, line.Quantity);
                _stockAvailabilityCache[(selectedOrder.ID, line.LineNum)] = hasSufficientStock;

                // Si hay un problema de stock, añadirlo al mensaje de error
                if (!hasSufficientStock)
                {
                    anyStockIssue = true;
                    errorMessageBuilder.AppendLine($"- Artículo: {line.ItemCode}, Requerido: {line.Quantity}, Disponible: {availableQuantity}, Diferencia: {line.Quantity - availableQuantity}");
                }
            }

            // Si hay algún problema de stock, actualizar el estado de error de la orden
            if (anyStockIssue)
            {
                try
                {
                    await _batchService.UpdateOrderErrorStatusAsync(selectedOrder.ID, errorMessageBuilder.ToString());
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error al actualizar estado de error: {ex.Message}");
                }
            }

            // Convertir las líneas al formato para la grid
            var lineItems = orderData.LineItems
                .Select(li => new OrderLineItem(
                    li.LineNum,
                    li.ItemCode,
                    li.Quantity,
                    li.Batch
                ))
                .ToList();

            selectedOrderItems = lineItems.AsQueryable();
        }

        // Segunda llamada a StateHasChanged para actualizar la grid de líneas
        StateHasChanged();
    }

    private async Task HandleDeleteClick(Order order)
    {
        if (order == null || order.ID <= 0) return;  // Ignorar clics en filas vacías

        var dialogResult = await _dialogService.ShowConfirmationAsync(
            $"¿Está seguro que desea eliminar la comanda {order.ID}?",
            "Confirmar eliminación");

        var result = await dialogResult.Result;
        if (result.Cancelled)
        {
            return; // Usuario canceló
        }

        // Eliminar de processedOrders
        processedOrders.RemoveAll(o => o.DocEntry == order.ID);

        // Actualizar la vista
        var orderList = processedOrders.Select(o => new Order(
            o.DocEntry,
            o.CardCode,
            DateOnly.FromDateTime(o.OrderDate),
            DateOnly.FromDateTime(o.DocDueDate),
            o.LineItems.Count
        )).ToList();

        orders = orderList.AsQueryable();

        // Actualizar el servicio compartido
        _selectedOrdersService.SetSelectedOrders(processedOrders);

        // Limpiar selección si el orden eliminado era el seleccionado
        if (selectedOrder != null && selectedOrder.ID == order.ID)
        {
            selectedOrder = null;
            selectedOrderItems = null;
        }

        StateHasChanged();
    }

    private bool HasSufficientStockForLine(OrderLineItem lineItem)
    {
        if (selectedOrder == null) return true;

        var key = (selectedOrder.ID, lineItem.LineNumber);

        // Consultar el cache per veure si aquesta línia té suficient stock
        if (_stockAvailabilityCache.TryGetValue(key, out bool hasStock))
        {
            return hasStock;
        }

        // Si no està al cache, assumim que sí té stock (per evitar errors)
        return true;
    }

    private async Task ProcessSelectedOrders()
    {
        if (processedOrders == null || !processedOrders.Any())
        {
            await _dialogService.ShowInfoAsync("No hay comandas para procesar.", "Información");
            return;
        }

        try
        {
            isLoading = true;
            StateHasChanged();

            // NUEVA VALIDACIÓN: Verificar stock insuficiente ANTES de procesar
            List<string> ordersWithInsufficientStock = new List<string>();

            foreach (var order in processedOrders)
            {
                foreach (var line in order.LineItems)
                {
                    var (hasSufficientStock, availableQuantity) = await _batchService.ValidateStockAvailabilityAsync(line.ItemCode, line.Quantity);

                    if (!hasSufficientStock)
                    {
                        ordersWithInsufficientStock.Add($"Orden {order.DocEntry}, Línea {line.LineNum + 1}: {line.ItemCode} (Necesario: {line.Quantity}, Disponible: {availableQuantity})");
                    }
                }
            }

            // Si hay stock insuficiente, bloquear el procesamiento
            if (ordersWithInsufficientStock.Any())
            {
                var errorMessage = new StringBuilder();
                errorMessage.AppendLine("No se puede procesar las comandas porque hay líneas con stock insuficiente:");
                errorMessage.AppendLine("");
                foreach (var error in ordersWithInsufficientStock)
                {
                    errorMessage.AppendLine("<br>");
                    errorMessage.AppendLine($"- {error}");
                }
                errorMessage.AppendLine("");

                await _dialogService.ShowErrorAsync(errorMessage.ToString(), "Stock Insuficiente");

                isLoading = false;
                StateHasChanged();
                return; // SALIR SIN PROCESAR
            }

            // Resto del código existente (verificar batches asignados, etc.)
            List<int> ordersWithMissingBatches = new List<int>();
            foreach (var order in processedOrders)
            {
                bool allAssigned = await _batchService.AllOrderLinesHaveBatchesAsync(order.DocEntry);
                if (!allAssigned)
                {
                    ordersWithMissingBatches.Add(order.DocEntry);
                }
            }

            // Si hay órdenes con batches sin asignar, mostrar diálogo de advertencia
            if (ordersWithMissingBatches.Any())
            {
                var message = new StringBuilder();
                message.AppendLine("Las siguientes comandas tienen productos sin lotes asignados:");
                message.AppendLine("");
                foreach (var orderId in ordersWithMissingBatches)
                {
                    message.AppendLine($"- Comanda {orderId}");
                }
                message.AppendLine("");
                message.AppendLine("¿Desea continuar y asignar lotes automáticamente?");

                var dialogResult = await _dialogService.ShowConfirmationAsync(
                    message.ToString(),
                    "Lotes no asignados");

                var result = await dialogResult.Result;
                if (result.Cancelled)
                {
                    isLoading = false;
                    StateHasChanged();
                    return; // Usuario canceló
                }

                // Asignar batches automáticamente a las órdenes que lo necesitan
                foreach (var orderId in ordersWithMissingBatches)
                {
                    await _batchService.AutoAssignBatchesToOrderAsync(orderId);
                }
            }

            // Mostrar resumen de las órdenes a procesar
            var summary = new StringBuilder();
            summary.AppendLine($"Se procesarán {processedOrders.Count} comandas:");
            summary.AppendLine("");

            foreach (var order in processedOrders)
            {
                summary.AppendLine($"- Orden {order.DocEntry}: {order.CardCode}, {order.LineItems.Count} líneas");
            }

            // Confirmación antes de procesar
            var processDialogResult = await _dialogService.ShowConfirmationAsync(
                summary.ToString(),
                "Confirmar Procesamiento");

            var processResult = await processDialogResult.Result;
            if (processResult.Cancelled)
            {
                isLoading = false;
                StateHasChanged();
                return;
            }

            // Lista para almacenar órdenes cuyo estado no se pudo actualizar
            List<int> failedStatusUpdates = new List<int>();

            // NUEVO: Actualizar el estado de IsProcessed a 1 para todas las órdenes
            foreach (var order in processedOrders)
            {
                try
                {
                    // Asumiendo que _batchService tiene acceso a SQLManagement o inyectarlo directamente
                    bool updateSuccess = await _batchService.UpdateOrderProcessedStatusAsync(order.DocEntry);

                    if (updateSuccess)
                    {
                        // Si la actualización del estado fue exitosa, guardar los lotes asignados
                        try
                        {
                            bool batchesSaved = await _batchService.SaveAssignedBatchesToDatabaseAsync(order.DocEntry, order.LineItems);
                            if (!batchesSaved)
                            {
                                Console.WriteLine($"Advertencia: No se pudieron guardar los lotes asignados para la orden {order.DocEntry}");
                            }
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Error al guardar lotes asignados para orden {order.DocEntry}: {ex.Message}");
                        }
                    }
                    else
                    {
                        failedStatusUpdates.Add(order.DocEntry);
                    }
                }
                catch (Exception ex)
                {
                    failedStatusUpdates.Add(order.DocEntry);
                    // Opcional: registrar el error
                    Console.WriteLine($"Error al actualizar estado de orden {order.DocEntry}: {ex.Message}");
                }
            }

            // Opcional: Mostrar advertencia si algunas órdenes no se actualizaron
            if (failedStatusUpdates.Any())
            {
                var warningMessage = new StringBuilder();
                warningMessage.AppendLine("No se pudo actualizar el estado de las siguientes comandas:");
                warningMessage.AppendLine("");
                foreach (var orderId in failedStatusUpdates)
                {
                    warningMessage.AppendLine($"- Comanda {orderId}");
                }

                await _dialogService.ShowWarningAsync(
                    warningMessage.ToString(),
                    "Advertencia");
            }

            // Simulación de procesamiento con progreso
            int totalOrders = processedOrders.Count;
            for (int i = 0; i < totalOrders; i++)
            {
                var order = processedOrders[i];
                await Task.Delay(500); // Simulación de procesamiento por orden

                // Opcional: confirmar cada orden en SAP
                bool sapResult = await _orderService.ConfirmOrderToSQL(order.DocEntry);
                if (!sapResult)
                {
                    await _dialogService.ShowWarningAsync($"Advertencia: La orden {order.DocEntry} no se pudo confirmar en SAP.", "Advertencia");
                }
            }

            // RESTAURAR EL JSON: Convertir las órdenes a formato JSON para mostrar y para la API
            string jsonOrders = ConvertOrdersToJson(processedOrders);

            var content = new StringContent(jsonOrders, Encoding.UTF8, "application/json");

            using var client = new HttpClient();
            var response = await client.PostAsync("http://localhost:8080/api/Order", content);

            string responseContent = "";
            if (response.IsSuccessStatusCode)
            {
                // Read the actual JSON response content
                responseContent = await response.Content.ReadAsStringAsync();

                await _dialogService.ShowInfoAsync(
                    responseContent,
                    "Éxito");
            }
            else
            {
                // Handle error responses
                string errorContent = await response.Content.ReadAsStringAsync();
                await _dialogService.ShowErrorAsync(
                    $"Error {response.StatusCode}: {errorContent}",
                    "Error en API");
            }

            // Limpiar después de procesar
            processedOrders.Clear();
            _selectedOrdersService.ClearSelectedOrders();
            orders = new List<Order>().AsQueryable();
            selectedOrder = null;
            selectedOrderItems = null;
        }
        catch (Exception ex)
        {
            await _dialogService.ShowErrorAsync($"Error al procesar comandas: {ex.Message}", "Error");
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // Método auxiliar para convertir las órdenes a formato JSON
    private string ConvertOrdersToJson(List<OrderData> orders)
    {
        try
        {
            // Crear un objeto anónimo que represente las órdenes en el formato deseado para la API
            var apiOrders = orders.Select(o => new
            {
                id = o.DocEntry,
                client = o.CardCode,
                orderDate = o.OrderDate.ToString("yyyy-MM-dd"),
                dueDate = o.DocDueDate.ToString("yyyy-MM-dd"),
                lines = o.LineItems.Select(li => new
                {
                    lineNumber = li.LineNum + 1,
                    itemCode = li.ItemCode,
                    quantity = li.Quantity,
                    batch = li.Batch // Esto incluirá los lotes asignados
                }).ToList()
            }).ToList();

            // Serializar a JSON con formato indentado para mejor visualización
            var options = new System.Text.Json.JsonSerializerOptions
                {
                    WriteIndented = true,
                    Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
                };

            return System.Text.Json.JsonSerializer.Serialize(apiOrders, options);
        }
        catch (Exception ex)
        {
            // En caso de error, devolver mensaje de error como JSON
            return $"{{ \"error\": \"Error al generar JSON: {ex.Message}\" }}";
        }
    }

    // Método para abrir el diálogo de asignación de batch
    private async Task OpenBatchAssignmentDialog(OrderLineItem lineItem)
    {
        if (lineItem == null || selectedOrder == null) return;

        // NOVA VALIDACIÓ: Verificar si hi ha suficient stock disponible
        var (hasSufficientStock, availableQuantity) = await _batchService.ValidateStockAvailabilityAsync(lineItem.ItemCode, lineItem.Quantity);

        if (!hasSufficientStock)
        {
            // Preparar el mensaje de error
            var message = $"No hi ha suficient stock disponible per al article {lineItem.ItemCode}.\n\n" +
                         $"Quantitat requerida: {lineItem.Quantity}\n" +
                         $"Quantitat disponible: {availableQuantity}\n" +
                         $"Diferència: {lineItem.Quantity - availableQuantity}";

            try
            {
                bool updateResult = await _batchService.UpdateOrderErrorStatusAsync(selectedOrder.ID, message);

                if (updateResult)
                {
                    // Opcional: indicar en el mensaje que se ha marcado la orden con error
                    message += "\n\nLa comanda ha sido marcada con error.";
                }
                else
                {
                    Console.WriteLine($"No se pudo actualizar el estado de error para la orden {selectedOrder.ID}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error al actualizar el estado de error: {ex.Message}");
                // Continuamos con la visualización del mensaje de error aunque falle la actualización
            }

            // Mostrar el mensaje de error al usuario
            await _dialogService.ShowErrorAsync(message, "Stock Insuficient");
            return; // No abrir el diálogo
        }

        // Si hay suficiente stock, continuar con la asignación normal
        currentOrderId = selectedOrder.ID;
        currentLineNumber = lineItem.LineNumber;
        currentItemCode = lineItem.ItemCode;
        currentQuantity = lineItem.Quantity;

        isBatchDialogOpen = true;
        StateHasChanged();
    }

    // Método para abrir el diálogo de información de batch
    private void OpenBatchInfoDialog(OrderLineItem lineItem)
    {
        if (lineItem == null || selectedOrder == null) return;

        currentOrderId = selectedOrder.ID;
        currentLineNumber = lineItem.LineNumber;
        currentItemCode = lineItem.ItemCode;
        currentQuantity = lineItem.Quantity;

        isInfoDialogOpen = true;
        StateHasChanged();
    }

    // Método para manejar el cierre del diálogo de asignación
    private void HandleDialogClosed(bool isOpen)
    {
        isBatchDialogOpen = isOpen;
        StateHasChanged();
    }

    // Método para manejar el cierre del diálogo de información
    private void HandleInfoDialogClosed(bool isOpen)
    {
        isInfoDialogOpen = isOpen;

        // Si se acaba de cerrar el diálogo, recargar la vista
        if (!isOpen && selectedOrder != null)
        {
            // Forzar una actualización de la interfaz
            InvokeAsync(StateHasChanged);
        }
    }

    // Método para manejar la asignación exitosa de un batch
    private async Task HandleBatchAssigned(bool success)
    {
        if (success)
        {
            // Actualizar la vista de detalle
            if (selectedOrder != null)
            {
                // Recargar los detalles de la orden seleccionada
                var orderData = processedOrders.FirstOrDefault(o => o.DocEntry == selectedOrder.ID);
                if (orderData != null && orderData.LineItems.Any())
                {
                    // Convertir las líneas al formato para la grid
                    var lineItems = orderData.LineItems
                        .Select(li => new OrderLineItem(
                            li.LineNum,
                            li.ItemCode,
                            li.Quantity,
                            li.Batch
                        ))
                        .ToList();

                    selectedOrderItems = lineItems.AsQueryable();
                    StateHasChanged();
                }
            }

            await _dialogService.ShowInfoAsync("Lote asignado correctamente.", "Éxito");
        }
    }

    private async Task ConfirmOrderToSAP(int orderId)
    {
        try
        {
            bool result = await _orderService.ConfirmOrderToSQL(orderId);

            if (result)
            {
                await _dialogService.ShowInfoAsync($"Orden {orderId} confirmada en SAP con éxito.", "Confirmación");
            }
            else
            {
                await _dialogService.ShowErrorAsync($"No se pudo confirmar la orden {orderId} en SAP.", "Error");
            }
        }
        catch (Exception ex)
        {
            await _dialogService.ShowErrorAsync($"Error al confirmar la orden en SAP: {ex.Message}", "Error");
        }
    }

    public void Dispose()
    {
        refreshTimer?.Dispose();
    }
}